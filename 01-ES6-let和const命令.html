<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <script>
        /*
        let和const声明的变量:  不存在变量提升  暂时性死区(TDZ)
                              暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
        let: 不允许在相同作用域,重复声明同一个变量
        const: 声明一个常量,一旦声明就不能改变  const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
     
        */

        // 1>:
        // for(let i = 0; i< 3; i++){
        //     let i = 'abc';
        //     console.log(i);
        // }

        // 2>:
        // var tmp = 123;

        // if(true){
        //     // TDZ开始
        //     // tmp = 'abc';   //报错 tmp is not defined
        //     // console.log(tmp);  //报错

        //     let tmp;
        //     console.log(tmp) //undefined

        //     tmp = 123
        //     console.log(tmp)  //123
        // }

        // 3>:
        // function bar(x = y, y = 2) {
        //     return [x,y];
        //   }
        //   bar()   //Uncaught ReferenceError: y is not defined(y还没声明,属于死区)

        // 4>:
        //   var x = x;  //不会报错
        //   let x = x;  //Uncaught ReferenceError: x is not defined  报错
        // let声明的变量,只要还没在声明完成前使用,就会报错,变量x声明语句还没执行完成前,就取x的值,使用报错

        // 5>:
        // let x = 10;
        // let x = 5;
        // console.log(x)   //Identifier 'x' has already been declared   不允许在同一个作用域内,重复声明

        /* 6>:  内层变量覆盖外层变量
               用来计数的循环变量泄露为全局变量  */
        // var tmp = 'outworld';

        // function fn() {
        //     console.log(tmp);
        //     if(false){
        //         var tmp = 'insideworld'
        //     }
        //   }

        //   fn()  //undefinde



        // (typeof window !== 'undefined' ? window : (typeof process === 'object' &&typeof require === 'function' &&   typeof global === 'object') ? global : this);


    </script>
</body>

</html>