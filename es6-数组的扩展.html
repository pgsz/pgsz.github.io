<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <script>
        /* 一: 扩展运算符 (...)  将一个数组转为用逗号分隔的参数序列 */

        /* 扩展运算符与正常的函数结合使用  扩展运算符后面可以放置表达式 */
        // console.log(...[1, 2, 3, 4]) // 1 2 3 4
        // console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5

        // function f(v, w, x, y, z) {
        //     console.log(v, w, x, y, z)
        // }
        // const args = [0, 1];
        // f(-1, ...args, 2, ...[3]); // -1 0 1 2 3

        /* 替代函数apply的方法:由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了 */
        // ES5 的写法
        // 利用apply传值的特点,可以传数组. 第一个参数为:改变this指向
        // Math.max.apply(null, [14, 3, 77])
        // // ES6 的写法
        // Math.max(...[14, 3, 77])
        // // 等同于
        // Math.max(14, 3, 77);

        // ES5的 写法
        // var arr1 = [0, 1, 2];
        // var arr2 = [3, 4, 5];
        // console.log(Array.prototype.push.apply(arr1, arr2))   // 6  返回的是新数组的长度
        // console.log(arr1)  // [0,1,2,3,4,5,6]
        // // ES6 的写法
        // let arr1 = [0, 1, 2];
        // let arr2 = [3, 4, 5];
        // console.log(arr1.push(...arr2))  // 6
        // console.log(arr1)  // [0,1,2,3,4,5,6]

        /* 复制数组  合并数组 */
        /* concat()  1. 该方法不会改变原有的数组。参数可以是array，string，number，object。
                     2. 返回一个新的数组，如果有数组作为参数传入concat（）方法里时，添加的是数组中的元素而不是数组本身。 */
        // const a1 = [1, 2];
        // // 复制数组,修改a2对a1没影响
        // const a2 = a1.concat();
        // console.log(a2) // 1 2
        // a2[0] = 2;
        // console.log(a2) // 1 2
        // console.log(a1) // [1, 2]

        // const a1 = [1, 2];
        // // 写法一
        // const a2 = [...a1];
        // a2[0] = 2;
        // console.log(a1)   // [1,2]
        // console.log(a2)   // [2,2]
        // // 写法二
        // const [...a2] = a1;

        // const a1 = [{
        //     foo: 1
        // }];
        // const a2 = [{
        //     bar: 2
        // }];
        // const a3 = a1.concat(a2);
        // const a4 = [...a1, ...a2];
        // console.log(a3)
        // console.log(a4)
        // console.log(a3[0] === a1[0]) // true
        // console.log(a4[1] === a2[0]) // true
        /* a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。 */

        /* 与解构赋值结合,生成新的数组 */
        // const [first, ...rest] = [1, 2, 3, 4, 5];
        // console.log(first) // 1
        // console.log(rest) // [2, 3, 4, 5]
        // const [first, ...rest] = [];
        // first // undefined
        // rest // []
        // const [first, ...rest] = ["foo"];
        // first // "foo"
        // rest // []
         /* 扩展运算符用于数组赋值,只能放最后一位,否则报错 */
        // const [...butLast, last] = [1, 2, 3, 4, 5];  //报错

        /* 字符串:  将字符串转换为真正的数组 */
        // console.log([...'hello']) // ["h", "e", "l", "l", "o"]


        /* 二:  Array.from() */
        /* Array.from方法将两类对象转换为真正的数组
                    1. 类似数组的对象 (array-like object)
                    2. 可遍历(iterable)的对象
         */


    </script>

</body>

</html>